我们知道在TCP长连接或者WebSocket长连接中一般我们都会使用心跳机制–即发送特殊的数据包来通告对方自己的业务还没有办完，不要关闭链接。那么心跳机制可以用来做什么呢？我们知道网络的传输是不可靠的，当我们发起一个链接请求的过程之中会发生什么事情谁都无法预料，或者断电，服务器重启，断网线之类。如果有这种情况的发生对方也无法判断你是否还在线。所以这时候我们引入心跳机制，在长链接中双方没有数据交互的时候互相发送数据(可能是空包，也可能是特殊数据)，对方收到该数据之后也回复相应的数据用以确保双方都在线，这样就可以确保当前链接是有效的。

1. 如何实现心跳机制
一般实现心跳机制由两种方式：

TCP协议自带的心跳机制来实现；
在应用层来实现。
但是TCP协议自带的心跳机制系统默认是设置的是2小时的心跳频率。它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。另外该心跳机制是与TCP协议绑定的，那如果我们要是使用UDP协议岂不是用不了？所以一般我们都不用。

而一般我们自己实现呢大致的策略是这样的：

1、Client启动一个定时器，不断发送心跳；
2、Server收到心跳后，做出回应；
3、Server启动一个定时器，判断Client是否存在，这里做判断有两种方法：时间差和简单标识。

时间差：
1、收到一个心跳包之后记录当前时间；
2、判断定时器到达时间，计算多久没收到心跳时间=当前时间-上次收到心跳时间。如果改时间大于设定值则认为超时。

简单标识：
1、收到心跳后设置连接标识为true;
2、判断定时器到达时间，如果未收到心跳则设置连接标识为false;

今天我们来看一下Netty的心跳机制的实现，在Netty中提供了IdleStateHandler类来进行心跳的处理，它可以对一个 Channel 的 读/写设置定时器, 当 Channel 在一定事件间隔内没有数据交互时(即处于 idle 状态), 就会触发指定的事件。

该类可以对三种类型的超时做心跳机制检测：

public IdleStateHandler(int readerIdleTimeSeconds, int writerIdleTimeSeconds, int allIdleTimeSeconds) {
    this((long)readerIdleTimeSeconds, (long)writerIdleTimeSeconds, (long)allIdleTimeSeconds, TimeUnit.SECONDS);
}


readerIdleTimeSeconds：设置读超时时间；
writerIdleTimeSeconds：设置写超时时间；
allIdleTimeSeconds：同时为读或写设置超时时间；
下面我们还是通过一个例子来讲解IdleStateHandler的使用





我们再来屡一下思路：

首先客户端激活channel，因为客户端中并没有发送消息所以会触发客户端的IdleStateHandler，它设置的写超时时间为3s；
然后触发客户端的事件机制进入userEventTriggered方法，在触发器中计数并向客户端发送消息；
服务端接收消息；
客户端触发器继续轮询发送消息，直到计数器满不再向服务端发送消息；
服务端在IdleStateHandler设置的读消息超时时间5s内未收到消息，触发了服务端中handler的userEventTriggered方法，于是关闭客户端的链接。
大体我们的简单心跳机制就是这样的思路，通过事件触发机制以及计数器的方式来实现，上面我们的案例中最后客户端没有发送消息的时候我们是强制断开了客户端的链接，那么既然可以关闭，我们是不是也可是重新链接客户端呢？因为万一客户端本身并不想关闭而是由于别的原因导致他无法与服务端通信。下面我们来说一下重连机制。

当我们的服务端在未读到客户端消息超时而关闭客户端的时候我们一般在客户端的finally块中方的是关闭客户端的代码，这时我们可以做一下修改的，finally是一定会被执行新的，所以我们可以在finally块中重新调用一下启动客户端的代码，这样就又重新启动了客户端了，上客户端代码：
